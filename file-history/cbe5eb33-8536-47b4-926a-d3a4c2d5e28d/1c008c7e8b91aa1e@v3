#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
QQé‚®ç®±IMAPé‚®ä»¶è¯»å–å·¥å…·
æ”¯æŒè¯»å–æœ€è¿‘Nå°é‚®ä»¶ï¼Œæ”¯æŒæˆæƒç ç™»å½•
"""

import imaplib
import email
from email.header import decode_header
import re
import sys
import os
from datetime import datetime
from pathlib import Path

# Windowsç¼–ç ä¿®å¤
if sys.platform == 'win32':
    import io
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
    sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8')

# é‚®ç®±é…ç½®
IMAP_SERVER = "imap.qq.com"
IMAP_PORT = 993

def load_env_file(env_path=None):
    """åŠ è½½.envæ–‡ä»¶"""
    if env_path is None:
        # æŸ¥æ‰¾.envæ–‡ä»¶ï¼ˆå½“å‰ç›®å½•ã€ä¸Šçº§ç›®å½•ã€é¡¹ç›®æ ¹ç›®å½•ï¼‰
        current_dir = Path.cwd()
        possible_paths = [
            current_dir / '.env',
            current_dir.parent / '.env',
            Path(__file__).parent.parent.parent / '.env'
        ]

        for path in possible_paths:
            if path.exists():
                env_path = path
                break

    if env_path and env_path.exists():
        try:
            with open(env_path, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    # è·³è¿‡æ³¨é‡Šå’Œç©ºè¡Œ
                    if not line or line.startswith('#'):
                        continue
                    # è§£æKEY=VALUE
                    if '=' in line:
                        key, value = line.split('=', 1)
                        key = key.strip()
                        value = value.strip()
                        # å¦‚æœç¯å¢ƒå˜é‡è¿˜æ²¡è®¾ç½®ï¼Œåˆ™ä».envæ–‡ä»¶åŠ è½½
                        if key not in os.environ:
                            os.environ[key] = value
            return True
        except Exception as e:
            print(f"âš ï¸  è­¦å‘Š: æ— æ³•åŠ è½½.envæ–‡ä»¶ - {e}")
            return False
    return False

def decode_mime_words(header_value):
    """è§£ç é‚®ä»¶å¤´"""
    if header_value is None:
        return ""

    decoded_list = decode_header(header_value)
    decoded_string = ""

    for content, encoding in decoded_list:
        if isinstance(content, bytes):
            if encoding:
                try:
                    decoded_string += content.decode(encoding)
                except:
                    decoded_string += content.decode('utf-8', errors='ignore')
            else:
                decoded_string += content.decode('utf-8', errors='ignore')
        else:
            decoded_string += str(content)

    return decoded_string

def get_email_body(msg):
    """æå–é‚®ä»¶æ­£æ–‡"""
    body = ""

    if msg.is_multipart():
        for part in msg.walk():
            content_type = part.get_content_type()
            content_disposition = str(part.get("Content-Disposition"))

            # è·å–æ–‡æœ¬å†…å®¹
            if content_type == "text/plain" and "attachment" not in content_disposition:
                try:
                    payload = part.get_payload(decode=True)
                    charset = part.get_content_charset() or 'utf-8'
                    body += payload.decode(charset, errors='ignore')
                except:
                    pass
            elif content_type == "text/html" and "attachment" not in content_disposition and not body:
                try:
                    payload = part.get_payload(decode=True)
                    charset = part.get_content_charset() or 'utf-8'
                    body += payload.decode(charset, errors='ignore')
                except:
                    pass
    else:
        # éå¤šéƒ¨åˆ†é‚®ä»¶
        try:
            payload = msg.get_payload(decode=True)
            charset = msg.get_content_charset() or 'utf-8'
            body = payload.decode(charset, errors='ignore')
        except:
            body = str(msg.get_payload())

    return body

def format_email_size(size_bytes):
    """æ ¼å¼åŒ–é‚®ä»¶å¤§å°"""
    for unit in ['B', 'KB', 'MB', 'GB']:
        if size_bytes < 1024.0:
            return f"{size_bytes:.1f} {unit}"
        size_bytes /= 1024.0
    return f"{size_bytes:.1f} TB"

def read_qq_mails(email_address, auth_code, count=10, folder="INBOX"):
    """
    è¯»å–QQé‚®ç®±çš„æœ€è¿‘Nå°é‚®ä»¶

    å‚æ•°:
        email_address: QQé‚®ç®±åœ°å€
        auth_code: æˆæƒç ï¼ˆä¸æ˜¯QQå¯†ç ï¼‰
        count: è¯»å–é‚®ä»¶æ•°é‡ï¼Œé»˜è®¤10å°
        folder: é‚®ä»¶æ–‡ä»¶å¤¹ï¼Œé»˜è®¤INBOX

    è¿”å›: é‚®ä»¶åˆ—è¡¨
    """
    try:
        # è¿æ¥åˆ°IMAPæœåŠ¡å™¨
        print(f"ğŸ”Œ æ­£åœ¨è¿æ¥åˆ° {IMAP_SERVER}:{IMAP_PORT}...")
        mail = imaplib.IMAP4_SSL(IMAP_SERVER, IMAP_PORT)

        # ç™»å½•
        print(f"ğŸ” æ­£åœ¨ç™»å½• {email_address}...")
        mail.login(email_address, auth_code)

        # é€‰æ‹©æ–‡ä»¶å¤¹
        mail.select(folder)
        print(f"ğŸ“ å·²é€‰æ‹©æ–‡ä»¶å¤¹: {folder}")

        # æœç´¢æ‰€æœ‰é‚®ä»¶
        print(f"ğŸ” æ­£åœ¨æœç´¢é‚®ä»¶...")
        status, messages = mail.search(None, "ALL")

        if status != "OK":
            print("âŒ æœç´¢é‚®ä»¶å¤±è´¥")
            return []

        # è·å–é‚®ä»¶IDåˆ—è¡¨
        email_ids = messages[0].split()
        total_emails = len(email_ids)
        print(f"ğŸ“§ æ€»å…±æ‰¾åˆ° {total_emails} å°é‚®ä»¶")

        # è·å–æœ€è¿‘çš„Nå°é‚®ä»¶
        recent_ids = email_ids[-count:] if total_emails > count else email_ids
        print(f"ğŸ“¥ æ­£åœ¨è¯»å–æœ€è¿‘ {len(recent_ids)} å°é‚®ä»¶...\n")

        emails = []

        # å€’åºéå†ï¼ˆæœ€æ–°çš„åœ¨å‰ï¼‰
        for idx, email_id in enumerate(reversed(recent_ids), 1):
            # è·å–é‚®ä»¶
            status, msg_data = mail.fetch(email_id, "(RFC822)")

            if status != "OK":
                continue

            # è§£æé‚®ä»¶
            raw_email = msg_data[0][1]
            msg = email.message_from_bytes(raw_email)

            # æå–é‚®ä»¶ä¿¡æ¯
            email_info = {
                "åºå·": idx,
                "ä¸»é¢˜": decode_mime_words(msg.get("Subject")),
                "å‘ä»¶äºº": decode_mime_words(msg.get("From")),
                "æ”¶ä»¶äºº": decode_mime_words(msg.get("To")),
                "æ—¥æœŸ": msg.get("Date"),
                "å¤§å°": format_email_size(len(raw_email)),
                "æ­£æ–‡": get_email_body(msg)
            }

            # å¤„ç†æŠ„é€
            if msg.get("Cc"):
                email_info["æŠ„é€"] = decode_mime_words(msg.get("Cc"))

            emails.append(email_info)

        # å…³é—­è¿æ¥
        mail.close()
        mail.logout()

        return emails

    except imaplib.IMAP4.error as e:
        print(f"âŒ IMAPé”™è¯¯: {e}")
        print("\nå¯èƒ½çš„åŸå› :")
        print("1. æˆæƒç ä¸æ­£ç¡®ï¼ˆè¯·ç¡®è®¤ä½¿ç”¨çš„æ˜¯æˆæƒç ï¼Œä¸æ˜¯QQå¯†ç ï¼‰")
        print("2. IMAPæœåŠ¡æœªå¼€å¯ï¼ˆè¯·å‰å¾€QQé‚®ç®±è®¾ç½®ä¸­å¼€å¯IMAPæœåŠ¡ï¼‰")
        print("3. ç½‘ç»œè¿æ¥é—®é¢˜")
        return []

    except Exception as e:
        print(f"âŒ å‘ç”Ÿé”™è¯¯: {e}")
        return []

def display_emails(emails):
    """æ ¼å¼åŒ–æ˜¾ç¤ºé‚®ä»¶"""
    if not emails:
        print("ğŸ“­ æ²¡æœ‰æ‰¾åˆ°é‚®ä»¶")
        return

    print("=" * 80)
    print(f"ğŸ“§ æ”¶åˆ° {len(emails)} å°é‚®ä»¶")
    print("=" * 80)

    for email_info in emails:
        print(f"\n{'â”€' * 80}")
        print(f"ğŸ“¬ é‚®ä»¶ #{email_info['åºå·']}")
        print(f"{'â”€' * 80}")
        print(f"ğŸ“Œ ä¸»é¢˜: {email_info['ä¸»é¢˜']}")
        print(f"ğŸ‘¤ å‘ä»¶äºº: {email_info['å‘ä»¶äºº']}")
        print(f"ğŸ“¥ æ”¶ä»¶äºº: {email_info['æ”¶ä»¶äºº']}")
        if 'æŠ„é€' in email_info:
            print(f"ğŸ“§ æŠ„é€: {email_info['æŠ„é€']}")
        print(f"ğŸ“… æ—¥æœŸ: {email_info['æ—¥æœŸ']}")
        print(f"ğŸ“ å¤§å°: {email_info['å¤§å°']}")
        print(f"{'â”€' * 80}")
        print(f"ğŸ“ æ­£æ–‡:")
        print("â”€" * 80)

        # æˆªå–æ­£æ–‡å‰1000å­—ç¬¦
        body = email_info['æ­£æ–‡']
        if len(body) > 1000:
            body = body[:1000] + "\n\n... (å†…å®¹è¿‡é•¿ï¼Œå·²æˆªæ–­)"
        print(body)
        print(f"{'â”€' * 80}")

def main():
    """ä¸»å‡½æ•°"""
    # å°è¯•åŠ è½½.envæ–‡ä»¶
    env_loaded = load_env_file()
    if env_loaded:
        print("âœ… å·²åŠ è½½.envé…ç½®æ–‡ä»¶")

    # ä»ç¯å¢ƒå˜é‡æˆ–å‚æ•°è¯»å–é…ç½®
    email_address = os.getenv("QQMAIL_EMAIL")
    auth_code = os.getenv("QQMAIL_AUTH_CODE")

    # å¦‚æœç¯å¢ƒå˜é‡æ²¡æœ‰è®¾ç½®ï¼Œä»å‘½ä»¤è¡Œå‚æ•°è¯»å–
    if not email_address or not auth_code:
        if len(sys.argv) >= 3:
            email_address = sys.argv[1]
            auth_code = sys.argv[2]
        else:
            print("âŒ é”™è¯¯: è¯·æä¾›é‚®ç®±åœ°å€å’Œæˆæƒç ")
            print("\nä½¿ç”¨æ–¹æ³•:")
            print("  æ–¹å¼1 (ç¯å¢ƒå˜é‡):")
            print("    export QQMAIL_EMAIL=your@qq.com")
            print("    export QQMAIL_AUTH_CODE=your_auth_code")
            print("    python qqmail_reader.py")
            print("\n  æ–¹å¼2 (å‘½ä»¤è¡Œå‚æ•°):")
            print("    python qqmail_reader.py your@qq.com your_auth_code [é‚®ä»¶æ•°é‡]")
            print("\nğŸ“– å¦‚ä½•è·å–æˆæƒç :")
            print("  1. ç™»å½• QQé‚®ç®±ç½‘é¡µç‰ˆ")
            print("  2. è¿›å…¥ è®¾ç½® -> å¸å·ä¸å®‰å…¨")
            print("  3. ç‚¹å‡» è®¾å¤‡ç®¡ç† > æˆæƒç ç®¡ç†")
            print("  4. ç”Ÿæˆä¸€ä¸ªæ–°çš„æˆæƒç ")
            sys.exit(1)

    # è¯»å–é‚®ä»¶æ•°é‡
    count = 10
    if len(sys.argv) >= 4:
        try:
            count = int(sys.argv[3])
        except ValueError:
            print("âš ï¸  é‚®ä»¶æ•°é‡å‚æ•°æ— æ•ˆï¼Œä½¿ç”¨é»˜è®¤å€¼10")

    print(f"\n{'=' * 80}")
    print(f"ğŸ“§ QQé‚®ç®±è¯»å–å·¥å…·")
    print(f"{'=' * 80}\n")

    # è¯»å–é‚®ä»¶
    emails = read_qq_mails(email_address, auth_code, count)

    # æ˜¾ç¤ºé‚®ä»¶
    if emails:
        display_emails(emails)

    print(f"\n{'=' * 80}")
    print(f"âœ… å®Œæˆï¼")
    print(f"{'=' * 80}\n")

if __name__ == "__main__":
    main()
