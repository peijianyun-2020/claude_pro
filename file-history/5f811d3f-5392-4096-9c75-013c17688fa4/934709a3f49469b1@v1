# 广东电力现货价格预测系统 - 实施计划

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** 建立完整的广东电力日前和实时现货价格预测系统，支持每日滚动预测未来3天价格，用于交易决策和风险管理。

**Architecture:** 分层架构设计，包含数据采集、预处理、特征工程、双模型预测（LSTM+XGBoost）和模型融合。采用TDD开发，每日自动预测，每周增量学习，每月完全重构。

**Tech Stack:** Python 3.9+, pandas, numpy, scikit-learn, XGBoost, PyTorch, 和风天气API

---

## 阶段一：基础设施搭建

### Task 1: 创建项目目录结构

**Files:**
- Create: 所有项目目录

**Step 1: 创建完整目录结构**

```bash
# 创建所有必要的目录
mkdir -p data/processed data/predictions models
mkdir -p src/data_collection src/preprocessing src/models src/prediction src/evaluation
mkdir -p tests tests/data_collection tests/preprocessing tests/models tests/prediction
mkdir -p notebooks config docs
mkdir -p "基础数据/气象数据"
```

**Step 2: 创建requirements.txt**

```bash
cat > requirements.txt << 'EOF'
# 数据处理
pandas>=2.0.0
numpy>=1.24.0
openpyxl>=3.1.0

# 机器学习
scikit-learn>=1.3.0
xgboost>=2.0.0

# 深度学习
torch>=2.0.0

# 数据采集
requests>=2.31.0

# 可视化
matplotlib>=3.7.0
seaborn>=0.12.0

# 调度
apscheduler>=3.10.0

# 开发工具
jupyter>=1.0.0
pytest>=7.4.0
black>=23.0.0
EOF
```

**Step 3: 创建README.md**

```bash
cat > README.md << 'EOF'
# 广东电力现货价格预测系统

## 项目简介
用于预测广东省日前和实时现货价格，支持每日滚动预测未来3天价格。

## 目录结构
- 基础数据/: 原始数据（日前价格、实时价格、预测信息、气象数据）
- data/: 处理后的数据和预测结果
- models/: 保存的模型文件
- src/: 源代码
- tests/: 测试代码
- notebooks/: Jupyter notebooks用于开发和调试
- docs/: 文档

## 快速开始
1. 安装依赖: `pip install -r requirements.txt`
2. 运行主程序: `python main.py`

## 更多信息
查看 docs/plans/ 目录下的设计和实施文档。
EOF
```

**Step 4: 创建.gitignore**

```bash
cat > .gitignore << 'EOF'
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
venv/
.venv/
ENV/
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Jupyter Notebook
.ipynb_checkpoints
*.ipynb

# PyTorch
*.pth

# 模型文件
models/*.pkl
models/*.pth

# 数据文件（保留目录结构，忽略数据内容）
data/processed/*.csv
data/predictions/*.csv
基础数据/气象数据/*.csv

# IDE
.vscode/
.idea/
*.swp
*.swo

# 系统文件
.DS_Store
Thumbs.db
EOF
```

**Step 5: 验证目录结构**

```bash
# 查看创建的目录
ls -R
```

**Step 6: 提交**

```bash
git add .
git commit -m "feat: initialize project structure and dependencies"
```

---

### Task 2: 实现数据导入模块 - 读取日前价格Excel文件

**Files:**
- Create: `src/data_collection/__init__.py`
- Create: `src/data_collection/excel_reader.py`
- Create: `tests/data_collection/test_excel_reader.py`
- Create: `config/config.yaml`

**Step 1: 创建配置文件**

```bash
cat > config/config.yaml << 'EOF'
# 数据路径配置
data_paths:
  day_ahead: "基础数据/每日日前数据表"
  real_time: "基础数据/每日实时数据表"
  forecast_info: "基础数据/预测信息披露/广东"
  weather: "基础数据/气象数据"

  processed: "data/processed"
  predictions: "data/predictions"
  models: "models"

# 模型配置
models:
  day_ahead:
    lstm: "models/lstm_day_ahead.pkl"
    xgb: "models/xgb_day_ahead.pkl"
  real_time:
    lstm: "models/lstm_real_time.pkl"
    xgb: "models/xgb_real_time.pkl"

# 预测配置
prediction:
  horizon_days: 3  # 预测未来3天
  hours_per_day: 24  # 每天24个时点
  lookback_days: 30  # 使用过去30天数据

# 天气API配置
weather:
  api_key: ""  # 需要填写和风天气API key
  cities: ["广州", "深圳", "珠海", "汕头", "佛山"]
EOF
```

**Step 2: 编写测试 - 读取日前价格Excel**

```python
# tests/data_collection/test_excel_reader.py
import pytest
import pandas as pd
from pathlib import Path

from src.data_collection.excel_reader import ExcelReader


def test_read_day_ahead_price_single_file():
    """测试读取单个日前价格Excel文件"""
    reader = ExcelReader()

    # 使用现有的Excel文件进行测试
    test_file = "基础数据/每日日前数据表/20250701日前.xlsx"

    if not Path(test_file).exists():
        pytest.skip(f"测试文件不存在: {test_file}")

    df = reader.read_day_ahead_price(test_file)

    # 验证返回的是DataFrame
    assert isinstance(df, pd.DataFrame)

    # 验证包含数据（24个小时）
    assert len(df) == 24

    # 验证包含必要的列（需要根据实际Excel格式调整）
    assert len(df.columns) > 0


def test_read_day_ahead_price_multiple_files():
    """测试读取多个日前价格Excel文件并合并"""
    reader = ExcelReader()

    data_dir = "基础数据/每日日前数据表"
    if not Path(data_dir).exists():
        pytest.skip(f"数据目录不存在: {data_dir}")

    # 读取前3个文件
    df = reader.read_day_ahead_price_directory(data_dir, limit=3)

    # 验证返回合并后的DataFrame
    assert isinstance(df, pd.DataFrame)
    assert len(df) == 24 * 3  # 3天 × 24小时


def test_read_real_time_price_single_file():
    """测试读取单个实时价格Excel文件"""
    reader = ExcelReader()

    test_file = "基础数据/每日实时数据表/20250701实时.xlsx"

    if not Path(test_file).exists():
        pytest.skip(f"测试文件不存在: {test_file}")

    df = reader.read_real_time_price(test_file)

    # 验证返回的是DataFrame
    assert isinstance(df, pd.DataFrame)

    # 验证包含数据（24个小时）
    assert len(df) == 24
```

**Step 3: 运行测试验证失败**

```bash
pytest tests/data_collection/test_excel_reader.py -v
```

Expected: FAIL - ModuleNotFoundError: No module named 'src.data_collection.excel_reader'

**Step 4: 实现ExcelReader类**

```python
# src/data_collection/excel_reader.py
import pandas as pd
from pathlib import Path
from typing import Optional
import glob


class ExcelReader:
    """读取Excel格式的电力价格数据"""

    def read_day_ahead_price(self, filepath: str) -> pd.DataFrame:
        """
        读取日前价格Excel文件

        Args:
            filepath: Excel文件路径

        Returns:
            包含24小时价格数据的DataFrame
        """
        df = pd.read_excel(filepath)

        # 标准化列名（需要根据实际Excel格式调整）
        # 假设Excel包含时间和价格列
        if len(df.columns) >= 2:
            df.columns = ['timestamp', 'price'] + list(df.columns[2:])
        else:
            df.columns = ['price']

        # 确保有24行数据
        if len(df) != 24:
            raise ValueError(f"期望24小时数据，实际获得{len(df)}小时")

        # 从文件名提取日期
        filename = Path(filepath).stem
        date_str = filename.replace('日前', '').replace('.xlsx', '')
        df['date'] = date_str

        return df

    def read_real_time_price(self, filepath: str) -> pd.DataFrame:
        """
        读取实时价格Excel文件

        Args:
            filepath: Excel文件路径

        Returns:
            包含24小时价格数据的DataFrame
        """
        df = pd.read_excel(filepath)

        # 标准化列名
        if len(df.columns) >= 2:
            df.columns = ['timestamp', 'price'] + list(df.columns[2:])
        else:
            df.columns = ['price']

        # 确保有24行数据
        if len(df) != 24:
            raise ValueError(f"期望24小时数据，实际获得{len(df)}小时")

        # 从文件名提取日期
        filename = Path(filepath).stem
        date_str = filename.replace('实时', '').replace('.xlsx', '')
        df['date'] = date_str

        return df

    def read_day_ahead_price_directory(
        self, directory: str, limit: Optional[int] = None
    ) -> pd.DataFrame:
        """
        读取目录下所有日前价格Excel文件并合并

        Args:
            directory: 目录路径
            limit: 最多读取文件数，None表示读取全部

        Returns:
            合并后的DataFrame
        """
        pattern = str(Path(directory) / "*日前.xlsx")
        files = sorted(glob.glob(pattern))

        if limit:
            files = files[:limit]

        if not files:
            raise ValueError(f"目录中没有找到日前价格文件: {directory}")

        dfs = []
        for filepath in files:
            try:
                df = self.read_day_ahead_price(filepath)
                dfs.append(df)
            except Exception as e:
                print(f"警告: 读取文件失败 {filepath}: {e}")
                continue

        if not dfs:
            raise ValueError("没有成功读取任何文件")

        return pd.concat(dfs, ignore_index=True)

    def read_real_time_price_directory(
        self, directory: str, limit: Optional[int] = None
    ) -> pd.DataFrame:
        """
        读取目录下所有实时价格Excel文件并合并

        Args:
            directory: 目录路径
            limit: 最多读取文件数，None表示读取全部

        Returns:
            合并后的DataFrame
        """
        pattern = str(Path(directory) / "*实时.xlsx")
        files = sorted(glob.glob(pattern))

        if limit:
            files = files[:limit]

        if not files:
            raise ValueError(f"目录中没有找到实时价格文件: {directory}")

        dfs = []
        for filepath in files:
            try:
                df = self.read_real_time_price(filepath)
                dfs.append(df)
            except Exception as e:
                print(f"警告: 读取文件失败 {filepath}: {e}")
                continue

        if not dfs:
            raise ValueError("没有成功读取任何文件")

        return pd.concat(dfs, ignore_index=True)
```

**Step 5: 创建__init__.py**

```python
# src/data_collection/__init__.py
from .excel_reader import ExcelReader

__all__ = ['ExcelReader']
```

```python
# src/__init__.py
# 空文件
```

```python
# tests/__init__.py
# 空文件
```

```python
# tests/data_collection/__init__.py
# 空文件
```

**Step 6: 运行测试验证通过**

```bash
pytest tests/data_collection/test_excel_reader.py -v
```

Expected: PASS

**Step 7: 提交**

```bash
git add .
git commit -m "feat: implement Excel reader for day-ahead and real-time prices"
```

---

### Task 3: 探索性数据分析（EDA）- 理解数据格式和结构

**Files:**
- Create: `notebooks/01_exploratory_data_analysis.ipynb`

**Step 1: 创建Jupyter Notebook进行数据分析**

```python
# 在notebooks目录创建Jupyter notebook
# 内容包括以下cell

# Cell 1: 导入库
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import sys
sys.path.append('..')

from src.data_collection import ExcelReader

# 设置中文显示
plt.rcParams['font.sans-serif'] = ['SimHei']
plt.rcParams['axes.unicode_minus'] = False

# Cell 2: 读取日前价格数据
reader = ExcelReader()
da_df = reader.read_day_ahead_price_directory("基础数据/每日日前数据表", limit=7)

print("日前价格数据形状:", da_df.shape)
print("\n前几行数据:")
print(da_df.head())
print("\n数据类型:")
print(da_df.dtypes)
print("\n基本统计:")
print(da_df.describe())

# Cell 3: 读取实时价格数据
rt_df = reader.read_real_time_price_directory("基础数据/每日实时数据表", limit=7)

print("实时价格数据形状:", rt_df.shape)
print("\n前几行数据:")
print(rt_df.head())
print("\n数据类型:")
print(rt_df.dtypes)
print("\n基本统计:")
print(rt_df.describe())

# Cell 4: 检查Excel实际格式
# 读取单个文件查看实际列名和格式
import openpyxl

wb = openpyxl.load_workbook("基础数据/每日日前数据表/20250701日前.xlsx")
ws = wb.active

print("工作表名称:", wb.sheetnames)
print("\n前10行数据:")
for i, row in enumerate(ws.iter_rows(values_only=True), 1):
    print(row)
    if i >= 10:
        break

# Cell 5: 价格分布可视化
plt.figure(figsize=(12, 4))

plt.subplot(1, 2, 1)
plt.hist(da_df['price'].values, bins=50)
plt.title('日前价格分布')
plt.xlabel('价格 (元/MWh)')
plt.ylabel('频数')

plt.subplot(1, 2, 2)
plt.hist(rt_df['price'].values, bins=50)
plt.title('实时价格分布')
plt.xlabel('价格 (元/MWh)')
plt.ylabel('频数')

plt.tight_layout()
plt.show()

# Cell 6: 价格时间序列
plt.figure(figsize=(14, 6))

plt.subplot(2, 1, 1)
plt.plot(da_df['price'].values[:24*7])
plt.title('日前价格时间序列（7天）')
plt.xlabel('小时')
plt.ylabel('价格 (元/MWh)')
plt.grid(True)

plt.subplot(2, 1, 2)
plt.plot(rt_df['price'].values[:24*7])
plt.title('实时价格时间序列（7天）')
plt.xlabel('小时')
plt.ylabel('价格 (元/MWh)')
plt.grid(True)

plt.tight_layout()
plt.show()

# Cell 7: 日内价格模式
# 计算平均日内模式（每天相同时刻的平均值）
da_daily_pattern = da_df.groupby(da_df.index % 24)['price'].mean()
rt_daily_pattern = rt_df.groupby(rt_df.index % 24)['price'].mean()

plt.figure(figsize=(12, 5))
plt.plot(da_daily_pattern.values, label='日前价格', marker='o')
plt.plot(rt_daily_pattern.values, label='实时价格', marker='s')
plt.title('平均日内价格模式')
plt.xlabel('小时')
plt.ylabel('价格 (元/MWh)')
plt.legend()
plt.grid(True)
plt.xticks(range(0, 24, 2))
plt.show()

# Cell 8: 日前价格vs实时价格的相关性
if len(da_df) == len(rt_df):
    correlation = np.corrcoef(da_df['price'], rt_df['price'])[0, 1]
    print(f"日前价格与实时价格相关系数: {correlation:.4f}")

    plt.figure(figsize=(8, 6))
    plt.scatter(da_df['price'], rt_df['price'], alpha=0.5)
    plt.xlabel('日前价格 (元/MWh)')
    plt.ylabel('实时价格 (元/MWh)')
    plt.title('日前价格 vs 实时价格')
    plt.grid(True)
    plt.plot([da_df['price'].min(), da_df['price'].max()],
             [da_df['price'].min(), da_df['price'].max()],
             'r--', label='y=x')
    plt.legend()
    plt.show()

# Cell 9: 保存分析结论
print("""
=== 数据探索结论 ===

1. 数据格式: 需要根据实际Excel格式调整列名和数据读取逻辑
2. 数据质量: 检查缺失值、异常值
3. 价格范围: 记录最小值、最大值、平均值
4. 时间模式: 识别日内、周内、季节性模式
5. 相关性: 日前价格与实时价格的相关程度
6. 特征工程方向: 基于数据特征确定需要构造的特征
""")
```

**Step 2: 运行Notebook分析数据**

```bash
# 启动Jupyter
jupyter notebook

# 然后在浏览器中打开 notebooks/01_exploratory_data_analysis.ipynb 并运行所有cells
```

**Step 3: 基于分析结果更新ExcelReader**

根据Notebook中发现的实际Excel格式，更新`src/data_collection/excel_reader.py`中的列名处理逻辑。

**Step 4: 提交**

```bash
git add notebooks/01_exploratory_data_analysis.ipynb
git commit -m "feat: add exploratory data analysis notebook"
```

---

### Task 4: 实现数据预处理和特征工程模块

**Files:**
- Create: `src/preprocessing/__init__.py`
- Create: `src/preprocessing/feature_engineering.py`
- Create: `tests/preprocessing/test_feature_engineering.py`

**Step 1: 编写测试 - 特征工程**

```python
# tests/preprocessing/test_feature_engineering.py
import pytest
import pandas as pd
import numpy as np
from datetime import datetime, timedelta

from src.preprocessing.feature_engineering import FeatureEngineer


@pytest.fixture
def sample_price_data():
    """创建测试用的价格数据"""
    # 创建7天的测试数据（7天 × 24小时 = 168行）
    dates = pd.date_range(start='2025-07-01', periods=7, freq='D')
    data = []

    for date in dates:
        for hour in range(24):
            # 模拟价格：白天高，夜间低
            base_price = 300 + 100 * np.sin(2 * np.pi * hour / 24)
            data.append({
                'datetime': date + timedelta(hours=hour),
                'date': date.strftime('%Y%m%d'),
                'hour': hour,
                'price': base_price + np.random.normal(0, 20)
            })

    return pd.DataFrame(data)


def test_create_time_features(sample_price_data):
    """测试创建时间特征"""
    engineer = FeatureEngineer()
    df = engineer.create_time_features(sample_price_data)

    # 验证添加了时间特征列
    assert 'hour' in df.columns
    assert 'day_of_week' in df.columns
    assert 'month' in df.columns
    assert 'is_weekend' in df.columns

    # 验证时间特征值范围
    assert df['hour'].min() >= 0
    assert df['hour'].max() <= 23
    assert df['day_of_week'].min() >= 0
    assert df['day_of_week'].max() <= 6


def test_create_lag_features(sample_price_data):
    """测试创建滞后特征"""
    engineer = FeatureEngineer()
    df = engineer.create_lag_features(sample_price_data, price_col='price')

    # 验证添加了滞后特征
    assert 'price_lag_24' in df.columns  # 昨天同时刻
    assert 'price_lag_48' in df.columns  # 前天同时刻
    assert 'price_lag_168' in df.columns  # 上周同时刻

    # 验证滞后特征正确性
    # 第24行（第二天0点）的lag_24应该等于第0行（第一天0点）的价格
    assert df.loc[24, 'price_lag_24'] == df.loc[0, 'price']


def test_create_rolling_features(sample_price_data):
    """测试创建滚动统计特征"""
    engineer = FeatureEngineer()
    df = engineer.create_rolling_features(sample_price_data, price_col='price')

    # 验证添加了滚动特征
    assert 'price_rolling_mean_24' in df.columns
    assert 'price_rolling_std_24' in df.columns
    assert 'price_rolling_max_24' in df.columns
    assert 'price_rolling_min_24' in df.columns

    # 验证滚动窗口计算正确
    # 第24行的24小时滚动平均应该是前24个点的平均
    expected_mean = df.loc[0:23, 'price'].mean()
    assert abs(df.loc[24, 'price_rolling_mean_24'] - expected_mean) < 1e-10


def test_create_all_features(sample_price_data):
    """测试创建所有特征"""
    engineer = FeatureEngineer()
    df = engineer.create_all_features(sample_price_data, price_col='price')

    # 验证所有特征都存在
    expected_features = [
        'hour', 'day_of_week', 'month', 'is_weekend',
        'price_lag_24', 'price_lag_48', 'price_lag_168',
        'price_rolling_mean_24', 'price_rolling_std_24',
        'price_rolling_max_24', 'price_rolling_min_24'
    ]

    for feature in expected_features:
        assert feature in df.columns


def test_prepare_training_samples(sample_price_data):
    """测试准备训练样本"""
    engineer = FeatureEngineer()

    # 创建完整特征
    df = engineer.create_all_features(sample_price_data, price_col='price')

    # 准备训练样本：用过去30天预测未来3天
    # 由于测试数据只有7天，调整参数
    X, y = engineer.prepare_training_samples(
        df,
        lookback_days=3,  # 使用过去3天
        forecast_days=1,  # 预测1天
        target_col='price'
    )

    # 验证输出形状
    assert len(X) > 0
    assert len(y) > 0
    assert len(X) == len(y)

    # 验证X的形状：(样本数, 特征数)
    assert X.ndim == 2
    # 验证y的形状：(样本数, 24)  # 24小时
    assert y.shape[1] == 24
```

**Step 2: 运行测试验证失败**

```bash
pytest tests/preprocessing/test_feature_engineering.py -v
```

Expected: FAIL - ModuleNotFoundError

**Step 3: 实现FeatureEngineer类**

```python
# src/preprocessing/feature_engineering.py
import pandas as pd
import numpy as np
from typing import Tuple, List


class FeatureEngineer:
    """特征工程：构造时间序列预测所需的特征"""

    def create_time_features(self, df: pd.DataFrame, datetime_col: str = 'datetime') -> pd.DataFrame:
        """
        创建时间特征

        Args:
            df: 原始数据
            datetime_col: 时间列名

        Returns:
            添加了时间特征的DataFrame
        """
        df = df.copy()

        if datetime_col not in df.columns:
            # 如果没有datetime列，尝试从date和hour创建
            if 'date' in df.columns and 'hour' in df.columns:
                df['datetime'] = pd.to_datetime(df['date'] + ' ' + df['hour'].astype(str) + ':00:00')
            else:
                raise ValueError(f"找不到时间列: {datetime_col}")

        df[datetime_col] = pd.to_datetime(df[datetime_col])

        # 基本时间特征
        df['hour'] = df[datetime_col].dt.hour
        df['day_of_week'] = df[datetime_col].dt.dayofweek
        df['month'] = df[datetime_col].dt.month
        df['quarter'] = df[datetime_col].dt.quarter
        df['day_of_month'] = df[datetime_col].dt.day

        # 周末标识
        df['is_weekend'] = (df['day_of_week'] >= 5).astype(int)

        return df

    def create_lag_features(
        self,
        df: pd.DataFrame,
        price_col: str = 'price',
        lags: List[int] = [24, 48, 168]
    ) -> pd.DataFrame:
        """
        创建滞后特征

        Args:
            df: 原始数据
            price_col: 价格列名
            lags: 滞后期列表（小时）

        Returns:
            添加了滞后特征的DataFrame
        """
        df = df.copy()

        for lag in lags:
            df[f'{price_col}_lag_{lag}'] = df[price_col].shift(lag)

        return df

    def create_rolling_features(
        self,
        df: pd.DataFrame,
        price_col: str = 'price',
        windows: List[int] = [24, 48, 168]
    ) -> pd.DataFrame:
        """
        创建滚动统计特征

        Args:
            df: 原始数据
            price_col: 价格列名
            windows: 窗口大小列表（小时）

        Returns:
            添加了滚动特征的DataFrame
        """
        df = df.copy()

        for window in windows:
            df[f'{price_col}_rolling_mean_{window}'] = df[price_col].rolling(window=window).mean()
            df[f'{price_col}_rolling_std_{window}'] = df[price_col].rolling(window=window).std()
            df[f'{price_col}_rolling_max_{window}'] = df[price_col].rolling(window=window).max()
            df[f'{price_col}_rolling_min_{window}'] = df[price_col].rolling(window=window).min()

        return df

    def create_all_features(
        self,
        df: pd.DataFrame,
        price_col: str = 'price',
        datetime_col: str = 'datetime'
    ) -> pd.DataFrame:
        """
        创建所有特征

        Args:
            df: 原始数据
            price_col: 价格列名
            datetime_col: 时间列名

        Returns:
            添加了所有特征的DataFrame
        """
        df = self.create_time_features(df, datetime_col)
        df = self.create_lag_features(df, price_col)
        df = self.create_rolling_features(df, price_col)

        return df

    def prepare_training_samples(
        self,
        df: pd.DataFrame,
        lookback_days: int = 30,
        forecast_days: int = 3,
        target_col: str = 'price',
        feature_cols: List[str] = None
    ) -> Tuple[np.ndarray, np.ndarray]:
        """
        准备训练样本：滑动窗口构造

        Args:
            df: 完整特征数据
            lookback_days: 使用过去多少天的数据
            forecast_days: 预测未来多少天
            target_col: 目标列名
            feature_cols: 特征列名，None表示使用所有非目标列

        Returns:
            X: (样本数, 特征数)
            y: (样本数, forecast_days * 24)
        """
        if feature_cols is None:
            # 排除目标列和非特征列
            exclude_cols = [target_col, 'datetime', 'date']
            feature_cols = [col for col in df.columns if col not in exclude_cols]

        X_samples = []
        y_samples = []

        hours_per_day = 24
        lookback_hours = lookback_days * hours_per_day
        forecast_hours = forecast_days * hours_per_day

        # 滑动窗口
        for i in range(lookback_hours, len(df) - forecast_hours + 1):
            # 特征：过去lookback_hours小时的数据
            X_window = df.iloc[i - lookback_hours:i][feature_cols].values

            # 目标：未来forecast_hours小时的价格
            y_window = df.iloc[i:i + forecast_hours][target_col].values

            X_samples.append(X_window)
            y_samples.append(y_window)

        if len(X_samples) == 0:
            raise ValueError("数据量不足以构造训练样本")

        # 对于XGBoost等传统ML模型，需要将时间序列展平
        # X形状: (样本数, lookback_hours * 特征数)
        X = np.array(X_samples)
        X = X.reshape(X.shape[0], -1)

        # y形状: (样本数, forecast_hours)
        y = np.array(y_samples)

        return X, y

    def prepare_lstm_samples(
        self,
        df: pd.DataFrame,
        lookback_days: int = 30,
        forecast_days: int = 3,
        target_col: str = 'price',
        feature_cols: List[str] = None
    ) -> Tuple[np.ndarray, np.ndarray]:
        """
        准备LSTM训练样本：保持3D形状

        Args:
            df: 完整特征数据
            lookback_days: 使用过去多少天的数据
            forecast_days: 预测未来多少天
            target_col: 目标列名
            feature_cols: 特征列名

        Returns:
            X: (样本数, lookback_hours, 特征数)
            y: (样本数, forecast_hours)
        """
        if feature_cols is None:
            exclude_cols = [target_col, 'datetime', 'date']
            feature_cols = [col for col in df.columns if col not in exclude_cols]

        X_samples = []
        y_samples = []

        hours_per_day = 24
        lookback_hours = lookback_days * hours_per_day
        forecast_hours = forecast_days * hours_per_day

        for i in range(lookback_hours, len(df) - forecast_hours + 1):
            X_window = df.iloc[i - lookback_hours:i][feature_cols].values
            y_window = df.iloc[i:i + forecast_hours][target_col].values

            X_samples.append(X_window)
            y_samples.append(y_window)

        if len(X_samples) == 0:
            raise ValueError("数据量不足以构造训练样本")

        # X形状: (样本数, lookback_hours, 特征数)
        X = np.array(X_samples)

        # y形状: (样本数, forecast_hours)
        y = np.array(y_samples)

        return X, y
```

**Step 4: 创建__init__.py**

```python
# src/preprocessing/__init__.py
from .feature_engineering import FeatureEngineer

__all__ = ['FeatureEngineer']
```

```python
# tests/preprocessing/__init__.py
# 空文件
```

**Step 5: 运行测试验证通过**

```bash
pytest tests/preprocessing/test_feature_engineering.py -v
```

Expected: PASS

**Step 6: 提交**

```bash
git add .
git commit -m "feat: implement feature engineering module"
```

---

### Task 5: 实现baseline模型（简单基准）

**Files:**
- Create: `src/models/baseline.py`
- Create: `tests/models/test_baseline.py`

**Step 1: 编写测试**

```python
# tests/models/test_baseline.py
import pytest
import pandas as pd
import numpy as np
from datetime import datetime, timedelta

from src.models.baseline import BaselinePredictor


@pytest.fixture
def sample_data():
    """创建测试数据"""
    dates = pd.date_range(start='2025-07-01', periods=14, freq='D')
    data = []

    for date in dates:
        for hour in range(24):
            data.append({
                'datetime': date + timedelta(hours=hour),
                'price': 300 + 100 * np.sin(2 * np.pi * hour / 24) + np.random.normal(0, 20)
            })

    return pd.DataFrame(data)


def test_yesterday_baseline(sample_data):
    """测试昨天价格基准模型"""
    model = BaselinePredictor(method='yesterday')

    # 使用前7天"训练"，预测后1天
    train = sample_data.iloc[:7*24]
    test = sample_data.iloc[7*24:8*24]

    # 预测
    predictions = model.predict(train, forecast_days=1)

    # 验证预测形状
    assert len(predictions) == 24

    # 验证预测值：应该等于训练数据的最后一天
    expected = train.iloc[-24:]['price'].values
    np.testing.assert_array_almost_equal(predictions, expected)


def test_last_week_baseline(sample_data):
    """测试上周同日基准模型"""
    model = BaselinePredictor(method='last_week')

    train = sample_data.iloc[:7*24]
    predictions = model.predict(train, forecast_days=1)

    # 验证预测值：应该等于7天前的数据
    expected = train.iloc[-168:-144]['price'].values
    np.testing.assert_array_almost_equal(predictions, expected)


def test_moving_average_baseline(sample_data):
    """测试移动平均基准模型"""
    model = BaselinePredictor(method='moving_average', window=3)

    train = sample_data.iloc[:7*24]
    predictions = model.predict(train, forecast_days=1)

    # 验证预测形状
    assert len(predictions) == 24

    # 验证预测值：应该等于过去3天同时刻的平均
    for hour in range(24):
        indices = [-24 - hour, -48 - hour, -72 - hour]
        expected = train.iloc[indices]['price'].mean()
        assert abs(predictions[hour] - expected) < 1e-10


def test_evaluate_baseline(sample_data):
    """测试评估基准模型"""
    model = BaselinePredictor(method='yesterday')

    train = sample_data.iloc[:7*24]
    test = sample_data.iloc[7*24:8*24]

    # 评估
    mape = model.evaluate(test['price'].values, model.predict(train, forecast_days=1))

    # 验证MAPE是非负数
    assert mape >= 0
```

**Step 2: 运行测试**

```bash
pytest tests/models/test_baseline.py -v
```

Expected: FAIL

**Step 3: 实现BaselinePredictor**

```python
# src/models/baseline.py
import numpy as np
import pandas as pd
from typing import Literal


class BaselinePredictor:
    """基准预测模型：提供简单的预测方法作为性能基准"""

    def __init__(self, method: Literal['yesterday', 'last_week', 'moving_average'] = 'yesterday', window: int = 3):
        """
        Args:
            method: 预测方法
                - yesterday: 使用昨天的价格
                - last_week: 使用上周同日的价格
                - moving_average: 使用过去n天同时刻的移动平均
            window: 移动平均窗口（仅当method='moving_average'时使用）
        """
        self.method = method
        self.window = window

    def predict(self, historical_data: pd.DataFrame, forecast_days: int = 3) -> np.ndarray:
        """
        预测未来价格

        Args:
            historical_data: 历史数据DataFrame，必须包含'price'列
            forecast_days: 预测天数

        Returns:
            预测价格数组，形状为 (forecast_days * 24,)
        """
        if 'price' not in historical_data.columns:
            raise ValueError("historical_data必须包含'price'列")

        prices = historical_data['price'].values
        hours_per_day = 24
        forecast_hours = forecast_days * hours_per_day

        predictions = []

        for day in range(forecast_days):
            day_predictions = self._predict_one_day(prices, day)
            predictions.extend(day_predictions)

        return np.array(predictions)

    def _predict_one_day(self, prices: np.ndarray, day_offset: int) -> np.ndarray:
        """预测某一天的24小时价格"""
        if self.method == 'yesterday':
            # 使用昨天（day_offset天前）的价格
            start_idx = -24 * (day_offset + 1)
            end_idx = -24 * day_offset if day_offset > 0 else None
            return prices[start_idx:end_idx]

        elif self.method == 'last_week':
            # 使用7天前的价格
            start_idx = -24 * (day_offset + 7)
            end_idx = -24 * (day_offset + 6)
            return prices[start_idx:end_idx]

        elif self.method == 'moving_average':
            # 使用过去window天同时刻的移动平均
            day_predictions = []
            for hour in range(24):
                # 收集过去window天该时刻的价格
                hour_prices = []
                for d in range(1, self.window + 1):
                    idx = -24 * (day_offset + d) - (24 - hour) if hour > 0 else -24 * (day_offset + d)
                    hour_prices.append(prices[idx])
                day_predictions.append(np.mean(hour_prices))
            return np.array(day_predictions)

        else:
            raise ValueError(f"未知的预测方法: {self.method}")

    def evaluate(self, actual: np.ndarray, predicted: np.ndarray) -> float:
        """
        计算MAPE（平均绝对百分比误差）

        Args:
            actual: 实际值
            predicted: 预测值

        Returns:
            MAPE值
        """
        # 避免除零
        actual_nonzero = np.where(actual == 0, 1e-10, actual)
        mape = np.mean(np.abs((actual - predicted) / actual_nonzero)) * 100
        return mape
```

**Step 4: 创建__init__.py**

```python
# src/models/__init__.py
from .baseline import BaselinePredictor

__all__ = ['BaselinePredictor']
```

```python
# tests/models/__init__.py
# 空文件
```

**Step 5: 运行测试**

```bash
pytest tests/models/test_baseline.py -v
```

Expected: PASS

**Step 6: 提交**

```bash
git add .
git commit -m "feat: implement baseline predictor model"
```

---

## 阶段二：天气数据集成

### Task 6: 实现和风天气API数据采集

**Files:**
- Create: `src/data_collection/weather_api.py`
- Create: `tests/data_collection/test_weather_api.py`
- Create: `notebooks/02_weather_data_exploration.ipynb`

**Step 1: 编写测试框架**

```python
# tests/data_collection/test_weather_api.py
import pytest
from datetime import datetime, timedelta
from unittest.mock import Mock, patch

from src.data_collection.weather_api import WeatherDataCollector


@pytest.fixture
def collector():
    """创建天气数据采集器"""
    return WeatherDataCollector(api_key="test_key")


def test_collector_initialization(collector):
    """测试初始化"""
    assert collector.api_key == "test_key"
    assert len(collector.cities) > 0


@patch('requests.get')
def test_fetch_current_weather(mock_get, collector):
    """测试获取当前天气"""
    # 模拟API响应
    mock_response = Mock()
    mock_response.json.return_value = {
        "code": "200",
        "now": {
            "temp": "25",
            "windSpeed": "3",
            "precip": "0.0",
            "windDir": "东南风"
        }
    }
    mock_get.return_value = mock_response

    result = collector.fetch_current_weather("广州")

    assert result is not None
    assert 'temp' in result


@patch('requests.get')
def test_fetch_forecast_weather(mock_get, collector):
    """测试获取天气预报"""
    mock_response = Mock()
    mock_response.json.return_value = {
        "code": "200",
        "hourly": [
            {"fxTime": "2025-07-01T00:00+08:00", "temp": "24", "windSpeed": "2"},
            {"fxTime": "2025-07-01T01:00+08:00", "temp": "23", "windSpeed": "2"},
        ]
    }
    mock_get.return_value = mock_response

    result = collector.fetch_forecast_weather("广州", hours=24)

    assert result is not None
    assert len(result) > 0
```

**Step 2: 实现WeatherDataCollector**

```python
# src/data_collection/weather_api.py
import requests
import pandas as pd
from datetime import datetime, timedelta
from typing import List, Dict, Optional
import time


class WeatherDataCollector:
    """和风天气API数据采集器"""

    def __init__(self, api_key: str, cities: List[str] = None):
        """
        Args:
            api_key: 和风天气API密钥
            cities: 要采集的城市列表
        """
        self.api_key = api_key
        self.cities = cities or ["广州", "深圳", "珠海", "汕头", "佛山"]
        self.base_url = "https://devapi.qweather.com/v7"

    def fetch_current_weather(self, city: str) -> Optional[Dict]:
        """
        获取当前天气

        Args:
            city: 城市名称

        Returns:
            天气数据字典
        """
        url = f"{self.base_url}/weather/now"
        params = {
            "key": self.api_key,
            "location": self._get_city_id(city)
        }

        try:
            response = requests.get(url, params=params, timeout=10)
            response.raise_for_status()
            data = response.json()

            if data.get("code") == "200":
                return data.get("now")
            else:
                print(f"API返回错误: {data.get('code')}")
                return None

        except Exception as e:
            print(f"获取当前天气失败 {city}: {e}")
            return None

    def fetch_forecast_weather(self, city: str, hours: int = 24) -> List[Dict]:
        """
        获取逐小时天气预报

        Args:
            city: 城市名称
            hours: 获取未来多少小时

        Returns:
            天气预报数据列表
        """
        url = f"{self.base_url}/weather/24h"
        params = {
            "key": self.api_key,
            "location": self._get_city_id(city)
        }

        try:
            response = requests.get(url, params=params, timeout=10)
            response.raise_for_status()
            data = response.json()

            if data.get("code") == "200":
                hourly = data.get("hourly", [])
                return hourly[:hours]
            else:
                print(f"API返回错误: {data.get('code')}")
                return []

        except Exception as e:
            print(f"获取天气预报失败 {city}: {e}")
            return []

    def fetch_historical_weather(
        self, city: str, date: datetime
    ) -> Optional[Dict]:
        """
        获取历史天气数据（需要付费API或使用其他数据源）

        Args:
            city: 城市名称
            date: 日期

        Returns:
            历史天气数据
        """
        # 和风天气历史数据API需要付费
        # 这里可以使用国家气象科学数据中心的数据作为替代
        # 暂时返回None，后续实现
        print(f"历史天气数据需要从其他数据源获取: {city} {date}")
        return None

    def collect_all_cities_forecast(self, hours: int = 72) -> pd.DataFrame:
        """
        采集所有城市的天气预报

        Args:
            hours: 获取未来多少小时

        Returns:
            合并后的DataFrame
        """
        all_data = []

        for city in self.cities:
            print(f"采集 {city} 的天气预报...")
            forecast = self.fetch_forecast_weather(city, hours)

            if forecast:
                for item in forecast:
                    all_data.append({
                        'city': city,
                        'datetime': item.get('fxTime'),
                        'temp': float(item.get('temp', 0)),
                        'wind_speed': float(item.get('windSpeed', 0)),
                        'precip': float(item.get('precip', 0)),
                        'wind_dir': item.get('windDir', '')
                    })

            # 避免API限流
            time.sleep(0.5)

        if not all_data:
            return pd.DataFrame()

        df = pd.DataFrame(all_data)
        df['datetime'] = pd.to_datetime(df['datetime'])
        df['date'] = df['datetime'].dt.strftime('%Y%m%d')
        df['hour'] = df['datetime'].dt.hour

        return df

    def save_forecast_data(self, filepath: str, hours: int = 72):
        """
        采集并保存天气预报数据

        Args:
            filepath: 保存文件路径
            hours: 获取未来多少小时
        """
        df = self.collect_all_cities_forecast(hours)

        if not df.empty:
            df.to_csv(filepath, index=False, encoding='utf-8-sig')
            print(f"天气预报数据已保存到: {filepath}")
        else:
            print("没有获取到任何数据")

    def _get_city_id(self, city: str) -> str:
        """
        获取城市ID（和风天气的城市location ID）

        Args:
            city: 城市名称

        Returns:
            城市ID
        """
        # 主要城市ID（需要从和风天气城市查询API获取）
        city_ids = {
            "广州": "101280101",
            "深圳": "101280601",
            "珠海": "101280701",
            "汕头": "101280401",
            "佛山": "101280800",
            "东莞": "101281600",
            "中山": "101281700",
        }

        return city_ids.get(city, city)
```

**Step 3: 更新data_collection的__init__.py**

```python
# src/data_collection/__init__.py
from .excel_reader import ExcelReader
from .weather_api import WeatherDataCollector

__all__ = ['ExcelReader', 'WeatherDataCollector']
```

**Step 4: 创建天气数据探索Notebook**

```python
# notebooks/02_weather_data_exploration.ipynb
# Cell 1: 测试天气API
import sys
sys.path.append('..')

from src.data_collection import WeatherDataCollector
import pandas as pd

# 需要先在config/config.yaml中填写API key
api_key = "your_api_key_here"  # 替换为实际的API key
collector = WeatherDataCollector(api_key=api_key)

# Cell 2: 测试获取单个城市当前天气
current = collector.fetch_current_weather("广州")
print("广州当前天气:")
print(current)

# Cell 3: 获取天气预报
forecast = collector.fetch_forecast_weather("广州", hours=24)
print(f"\n未来24小时预报（共{len(forecast)}条）:")
print(forecast[:5])

# Cell 4: 采集所有城市预报
all_forecast = collector.collect_all_cities_forecast(hours=72)
print(f"\n所有城市预报数据形状: {all_forecast.shape}")
print(all_forecast.head())

# Cell 5: 分析天气数据
import matplotlib.pyplot as plt

plt.figure(figsize=(12, 6))
for city in all_forecast['city'].unique():
    city_data = all_forecast[all_forecast['city'] == city]
    plt.plot(city_data['temp'][:24], label=city, marker='o')

plt.title('各城市未来24小时温度预报')
plt.xlabel('小时')
plt.ylabel('温度 (°C)')
plt.legend()
plt.grid(True)
plt.show()
```

**Step 5: 运行测试**

```bash
pytest tests/data_collection/test_weather_api.py -v
```

**Step 6: 提交**

```bash
git add .
git commit -m "feat: implement weather data collection from QWeather API"
```

---

## 阶段三：模型开发

### Task 7: 实现XGBoost日前价格预测模型

**Files:**
- Create: `src/models/xgboost_model.py`
- Create: `tests/models/test_xgboost_model.py`

**Step 1: 编写测试**

```python
# tests/models/test_xgboost_model.py
import pytest
import numpy as np
import pandas as pd
from datetime import datetime, timedelta

from src.models.xgboost_model import XGBoostPricePredictor
from src.preprocessing import FeatureEngineer


@pytest.fixture
def sample_training_data():
    """创建训练样本数据"""
    # 创建30天的模拟数据
    dates = pd.date_range(start='2025-07-01', periods=30, freq='D')
    data = []

    for date in dates:
        for hour in range(24):
            data.append({
                'datetime': date + timedelta(hours=hour),
                'date': date.strftime('%Y%m%d'),
                'hour': hour,
                'price': 300 + 100 * np.sin(2 * np.pi * hour / 24) + np.random.normal(0, 30)
            })

    df = pd.DataFrame(data)

    # 创建特征
    engineer = FeatureEngineer()
    df = engineer.create_all_features(df, price_col='price')

    return df


def test_xgb_model_initialization():
    """测试XGBoost模型初始化"""
    model = XGBoostPricePredictor(model_type='day_ahead')

    assert model.model_type == 'day_ahead'
    assert model.model is not None


def test_xgb_model_training(sample_training_data):
    """测试XGBoost模型训练"""
    model = XGBoostPricePredictor(model_type='day_ahead')
    engineer = FeatureEngineer()

    # 准备训练数据
    X, y = engineer.prepare_training_samples(
        sample_training_data,
        lookback_days=7,
        forecast_days=1,
        target_col='price'
    )

    # 训练
    model.train(X, y)

    # 验证模型已训练
    assert model.is_trained


def test_xgb_model_prediction(sample_training_data):
    """测试XGBoost模型预测"""
    model = XGBoostPricePredictor(model_type='day_ahead')
    engineer = FeatureEngineer()

    # 准备数据
    X, y = engineer.prepare_training_samples(
        sample_training_data,
        lookback_days=7,
        forecast_days=1,
        target_col='price'
    )

    # 训练
    model.train(X, y)

    # 预测
    predictions = model.predict(X[:1])  # 预测第一个样本

    # 验证预测形状
    assert predictions.shape == (24,)


def test_xgb_model_evaluation(sample_training_data):
    """测试XGBoost模型评估"""
    model = XGBoostPricePredictor(model_type='day_ahead')
    engineer = FeatureEngineer()

    X, y = engineer.prepare_training_samples(
        sample_training_data,
        lookback_days=7,
        forecast_days=1,
        target_col='price'
    )

    # 训练
    model.train(X, y)

    # 评估
    metrics = model.evaluate(X, y)

    # 验证评估指标
    assert 'mape' in metrics
    assert 'mae' in metrics
    assert 'rmse' in metrics
    assert metrics['mape'] >= 0


def test_xgb_model_save_load(sample_training_data):
    """测试模型保存和加载"""
    import tempfile
    import os

    model1 = XGBoostPricePredictor(model_type='day_ahead')
    engineer = FeatureEngineer()

    X, y = engineer.prepare_training_samples(
        sample_training_data,
        lookback_days=7,
        forecast_days=1,
        target_col='price'
    )

    model1.train(X, y)

    # 保存模型
    with tempfile.NamedTemporaryFile(delete=False, suffix='.pkl') as f:
        model_path = f.name

    try:
        model1.save(model_path)

        # 加载模型
        model2 = XGBoostPricePredictor(model_type='day_ahead')
        model2.load(model_path)

        # 验证预测结果一致
        pred1 = model1.predict(X[:1])
        pred2 = model2.predict(X[:1])

        np.testing.assert_array_almost_equal(pred1, pred2)

    finally:
        if os.path.exists(model_path):
            os.remove(model_path)
```

**Step 2: 实现XGBoostPricePredictor**

```python
# src/models/xgboost_model.py
import numpy as np
import pandas as pd
import pickle
from typing import Literal, Dict, Tuple
import xgboost as xgb
from sklearn.metrics import mean_absolute_error, mean_squared_error


class XGBoostPricePredictor:
    """XGBoost价格预测模型"""

    def __init__(
        self,
        model_type: Literal['day_ahead', 'real_time'] = 'day_ahead',
        n_estimators: int = 100,
        max_depth: int = 6,
        learning_rate: float = 0.05
    ):
        """
        Args:
            model_type: 模型类型（日前或实时）
            n_estimators: 树的数量
            max_depth: 树的最大深度
            learning_rate: 学习率
        """
        self.model_type = model_type
        self.n_estimators = n_estimators
        self.max_depth = max_depth
        self.learning_rate = learning_rate
        self.model = None
        self.is_trained = False

        # 初始化模型
        self._init_model()

    def _init_model(self):
        """初始化XGBoost模型"""
        self.model = xgb.XGBRegressor(
            n_estimators=self.n_estimators,
            max_depth=self.max_depth,
            learning_rate=self.learning_rate,
            objective='reg:squarederror',
            random_state=42,
            n_jobs=-1
        )

    def train(self, X: np.ndarray, y: np.ndarray, validation_split: float = 0.2):
        """
        训练模型

        Args:
            X: 训练特征，形状 (样本数, 特征数)
            y: 训练目标，形状 (样本数, 24) - 24小时价格
            validation_split: 验证集比例
        """
        # 时间序列交叉验证：按时间顺序划分
        split_idx = int(len(X) * (1 - validation_split))

        X_train, X_val = X[:split_idx], X[split_idx:]
        y_train, y_val = y[:split_idx], y[split_idx:]

        # 训练模型
        self.model.fit(
            X_train, y_train,
            eval_set=[(X_val, y_val)],
            verbose=False
        )

        self.is_trained = True

    def predict(self, X: np.ndarray) -> np.ndarray:
        """
        预测

        Args:
            X: 特征数据，形状 (样本数, 特征数)

        Returns:
            预测结果，形状 (样本数, 24)
        """
        if not self.is_trained:
            raise ValueError("模型未训练，请先调用train()方法")

        return self.model.predict(X)

    def evaluate(self, X: np.ndarray, y: np.ndarray) -> Dict[str, float]:
        """
        评估模型

        Args:
            X: 验证特征
            y: 验证目标

        Returns:
            评估指标字典
        """
        if not self.is_trained:
            raise ValueError("模型未训练，请先调用train()方法")

        predictions = self.predict(X)

        # 计算指标
        mae = mean_absolute_error(y.flatten(), predictions.flatten())
        rmse = np.sqrt(mean_squared_error(y.flatten(), predictions.flatten()))

        # MAPE（避免除零）
        y_safe = np.where(y == 0, 1e-10, y)
        mape = np.mean(np.abs((y - predictions) / y_safe)) * 100

        return {
            'mae': mae,
            'rmse': rmse,
            'mape': mape
        }

    def save(self, filepath: str):
        """
        保存模型

        Args:
            filepath: 保存路径
        """
        model_data = {
            'model': self.model,
            'model_type': self.model_type,
            'n_estimators': self.n_estimators,
            'max_depth': self.max_depth,
            'learning_rate': self.learning_rate,
            'is_trained': self.is_trained
        }

        with open(filepath, 'wb') as f:
            pickle.dump(model_data, f)

    def load(self, filepath: str):
        """
        加载模型

        Args:
            filepath: 模型文件路径
        """
        with open(filepath, 'rb') as f:
            model_data = pickle.load(f)

        self.model = model_data['model']
        self.model_type = model_data['model_type']
        self.n_estimators = model_data['n_estimators']
        self.max_depth = model_data['max_depth']
        self.learning_rate = model_data['learning_rate']
        self.is_trained = model_data['is_trained']

    def get_feature_importance(self, feature_names: list = None) -> pd.DataFrame:
        """
        获取特征重要性

        Args:
            feature_names: 特征名称列表

        Returns:
            特征重要性DataFrame
        """
        if not self.is_trained:
            raise ValueError("模型未训练")

        importance = self.model.feature_importances_

        df = pd.DataFrame({
            'feature': feature_names if feature_names else [f'f{i}' for i in range(len(importance))],
            'importance': importance
        })

        return df.sort_values('importance', ascending=False)
```

**Step 3: 更新__init__.py**

```python
# src/models/__init__.py
from .baseline import BaselinePredictor
from .xgboost_model import XGBoostPricePredictor

__all__ = ['BaselinePredictor', 'XGBoostPricePredictor']
```

**Step 4: 运行测试**

```bash
pytest tests/models/test_xgboost_model.py -v
```

**Step 5: 提交**

```bash
git add .
git commit -m "feat: implement XGBoost price prediction model"
```

---

## 实施进度跟踪

### 已完成任务
- Task 1: ✓ 项目结构搭建
- Task 2: ✓ Excel数据读取模块
- Task 3: ✓ 探索性数据分析（需手动运行）
- Task 4: ✓ 特征工程模块
- Task 5: ✓ 基准模型
- Task 6: ✓ 天气数据采集（需API key）
- Task 7: ✓ XGBoost日前价格模型

### 待完成任务（将在后续会话中实现）

**阶段三（继续）**:
- Task 8: XGBoost实时价格预测模型
- Task 9: LSTM日前价格预测模型
- Task 10: LSTM实时价格预测模型
- Task 11: 模型融合

**阶段四**:
- Task 12: 完整预测流程
- Task 13: 自动化预测调度
- Task 14: 模型动态更新机制
- Task 15: 性能监控和评估

**阶段五**:
- Task 16: 完整回测系统
- Task 17: 可视化和报告生成

---

## 下一步行动

完成Task 1-7后，系统已具备：
1. ✅ 完整的项目结构和依赖管理
2. ✅ 数据读取和预处理能力
3. ✅ 特征工程模块
4. ✅ 基准性能评估
5. ✅ 天气数据采集能力
6. ✅ XGBoost预测模型

接下来需要：
1. 运行EDA notebook了解实际数据格式
2. 获取和风天气API key并测试
3. 继续实现LSTM模型和模型融合
4. 实现完整的预测和更新流程

---

**文档版本**: 1.0
**最后更新**: 2026-01-12
